# JS中预解释，内存，闭包，作用域

>"1"++是2  字符串++先转number
## 自定义属性
>一般是给某些元素增加一个自己起的属性名（不能是内置属性），来存储一些值的，比如说我们选项卡中用自定义属性来存储他的索引值，不用全局变量的好处只有自己可以修改。
>**注意：**函数也可以加自定义属性。
>也就是说，只要是引用数据类型都可以增加自定义属性。
>元素 . 自定义属性名=属性值
## 函数的赋值过程
>1.  浏览器检测他是什么数据类型，是函数的话就给他开辟一个堆内存
>2.  将函数当做字符串存起来
>3.  将地址赋值给函数名
**注意：**匿名函数的执行方法如下：
```
function (i){
var a=i;
return a
}
()(i)
```
**注意：**自执行函数写的时候最好在前面加上分号，以免报错。自执行函数的执行方法如下：
```
；（function（i）{
   return i;
}）(1)
```

## 预解释（变量提声）
>预解释：是一个过程，在作用域形成之后，代码执行之前，把所有带var关键字和function提前声明或定义
>声明：告诉浏览器这里有个变量，var 关键字只有声明
>定义：就是一个赋值的过程，在预解释的时候function即声明又定义
>预解释的时候遇到变量已经声明过了就不用声明了，但是需要重新定义
>作用域：
-   全局作用域：window下，一打开浏览器就会形成。
-  私有作用域：一个函数就是一个私有作用域，函数执行的时候，这个私有作用域就会形成。

```
变量只声明未定义就是undefined
console.log(obj1);
var obj={name:"111"};
console.log(fn);
输出下面整个fn
function fn(){
}
运行过程：
1.全局作用域形成
2.全局作用域下的预解释：var obj1 function fn=xxxfff000
3.代码执行：1.console.log(obj1)；undefined
```

>预解释的特殊情况
-   = 右边函数不进行预解释（函数作为值的时候不进行预解释）
-  return 后面的代码不执行但是需要预解释，return 出来的内容执行但是不进行预解释
-  不管if（）条件是否成立都进行预解释，但是只声明不定义。代码执行的时候，条件成立，优先给函数定义（赋值），然后在让代码从上倒下执行。声明的时候，当遇到变量名已经声明过了，就会报错。
```
if（"a" in window）{
   var a=0;
   function a(){
  }
}
这样写就就会报错，因为变量名已经声明过了。
```
-  条件中预解释的情况，预解释的是遇到变量名相同的时候（var 后面的变量或者function后面的函数名不能相同）会报错。
-  自执行函数，不进行预解释
-  预解释的时候遇到已经声明的变量，不需要声明，但是需要定义。
-  undefined++是NaN

>**注意：**全局作用域下的变量就是window下的一个属性

### 内存
>内存分为两种
-    堆内存：存储东西，一般都是存引用数据类型值的
-     栈内存：就是作用域   


##闭包

>闭包：是一种机制，函数执行的时候会形成一个私有作用域，来保护里面的变量不受外界的干扰，这种机制叫做闭包。
```
   function fn() {
        var f=0;
        f++;
        console.log(f)
    }
    //console.log(f);
    //全局：预解释：function fn=xxxfff000；代码执行：f没有报错了

    fn();
    //私有作用域
    //私有预解释：var f
    //代码执行：f=0,f++->f=1,
    var a=1;
    var b=2;
    function sum(a) {
      var b=10;
      a++;
      b++;
      console.log(a,b)
    }
    sum(a);
    console.log(a,b)
    //全局预解释：var a，b,function sum=xxxfff000
    //全局执行：a=1,b=2 ,sum(1)形成一个私有作用域
    //1.给参数赋值，a=1
    //2.私有作用域预解释：var b
    //3.b=10,a=2,b=11
    //全局中 console.log(a,b);1,2
```
#### 私有变量
>**分类**：
-   参数
-  在私有作用域中声明（var function）的变量

#### 函数执行的步骤
>1.形成私有作用域
>2.给形参赋值，相当于var了一个变量（形参）
>3.预解释
>4.函数体执行

#### 作用域链
>在私有作用域下遇到变量先看是不是自己的私有变量（两种，详情看上面），是的话就是私有的，不是的话就往上一级找，如果还没有就继续找，直到找到全局为止，还没找到就报错了，这种查找机制叫做作用域链，私有作用域下的私有变量外界访问不到，但是私有作用域里面的可以获取外界的变量。

#### 查找上一级作用域
>看当前这个函数对应的堆内存在哪个作用域下定义的，那么他的上一级就是这个作用域，跟在哪里执行没有关系
>当遇到变量的时候，先看是不是自己的私有变量，如果是就用自己私有的，不是的话就一级一级的往上找，知道找到全局作用域，在没有，就报错。
```
<script type="text/javascript">
    var num=1;
    function fn() {
        var num=10;
        function ff() {
           console.log(num) ;
        }
        return ff
    }
    var ff=fn();
    console.log(ff());
    //全局变量：num，ff=xxxfff111，fn（函数）
    //私有变量：num，ff（函数）=xxxfff111
```

#### 堆内存
>来存储东西，一般来存储引用数据类型
>销毁机制：
>只要这个堆内存没有被 任何变量或者属性占用，浏览器就会主动将他销毁，其他的需要手动销毁，注意以后在做项目的时候遇到一个对象后面就不用了。手动清空以下：obj=null；

#### 栈内存(作用域)
>代码执行空间。分为：
>全局作用域：关闭浏览器的时候销毁，以后在做项目的时候尽量避免全局变量的使用。
>私有作用域：相同的函数，每一次执行都会想成一个私有作用域，他们之间都没有任何关系。
>私有作用域的销毁机制：
 -   立即销毁：函数没有返回值，或者返回的内容没有被占用，那浏览器就会把他销毁。  
 -  暂时不销毁：函数有返回值，返回了一个函数，这个函数马上就执行了，执行完之后，浏览器就会抽时间销毁。（具体什么时候销毁，每个浏览器的机制不一样，销毁的时间也不一样）
 -  不销毁：函数执行返回一个引用数据类型的地址，地址被一直被外界你变量占用。（主要用于给元素绑定时间的时候）

## This

### 执行的主体
>谁执行的就是主体就是谁。
>全局作用域下：this就是window。
>私有作用域下：
-   自执行函数中的this永远是window
-  给元素绑定时间的时候给谁绑定的this就是谁
-  函数执行的时候，看前面有没有点，有的话点前面是谁this就是谁，没有点的话就是window
-  函数作为参数的时候，this是window
```
[1,2,3].sort(function(a,b){
       console.log(this);
       return a-b;
})
sort前面的this是[1,2,3]
function里面的this是window
```


>**注意：**注意上下文，this不是上下文。
