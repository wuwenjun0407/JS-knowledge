# JS中数组和面向对象，原型
# 数组和面向对象
## 面向对象
>面向对象开发，面向对象思想。
>在JS中万物皆对象
>类：比如自然界有人类，动物类，植物类。。。
>在JS中我们大体分为两种：【内置类】  【自定义类】
>Object是所有类的基类，就是最顶层的类，查找到最后就是它。
##### 内置类
>每一种数据类型都是一个类，比如：Number，String,  Boolran,  Null, Undefined, Array, Object, Dat
>**注意：**Math 不是一个类，就是一个对象。
>元素都有自己的内置类

## 单例模式 模块化开发
>在之前obj1，obj2就是一个简单的对象，在这里我们加上一个高大上的名字，叫做命名空间。
>模块化开发：将一个完整的项目分模块，多个人共同开发，每个人分的模块写在一个对象里面，就是单例模式
>**注意：**单例一个模式就是一个对象，为了解决命名冲突问题。单例函数之间用this相互调用，this指的是单例模式的对象。

## 工厂模式
>工厂模式：我们把实现相同功能的方法封装成一个函数，以后在想实现这个功能就不用在写一遍代码了，直接执行函数，通过参数来得到具体的实例
>批量生产：低耦合高内聚，减少代码冗（rong）余，提高代码利用率。
>在JS内只有重写（相同的函数名后面会把前面的覆盖）没有重载
>如果想在JS 中实现重载的原理，就不要写形参，用arguments处理

## 构造函数
>构造函数函数名首字母要大写
>函数的三重身份：
-   1. 普通的函数,就代表一个方法
-   2.类 自定义类
-   3.它是Function类的一个实例
```
var obj=new Fn（）；
```
>new：就是构造函数的创建方式，Fn函数就是一个类，obj就是Fn类的一个实例
>实例是一个对象
>Fn（）执行创建的过程：
-  1. 形成一个私有作用域
-  2.预解释
-  3.自动创建一个实例，就是this
-  4.代码执行的时候，通过this给实例增加私有属性，并赋值
-  5.会默认返回当前的这个实例，也就是this
>**注意：**每个实例之间的地址都不一样
>**注意：**通过this给实例增加的是私有属性，每个实例之间的私有属性是私有的不一样
>**注意：**不用写return直接返回this，如果写了，写的是基本数据类型的没有影响，如果写的是引用数据类型的就会把返回的值修改了，写的是什么就返回什么。
>**注意：**var obj = new Fn() 和 var obj = new Fn 是一样的，没有区别。
>**注意：**在构造函数里面this就是实例
>可以理解为看到new那就是后面的类中的this就变成前面的实例
```
function Fn(){
   this . name=1
}
var a=new Fn()
Fn中的this就是a
```
#### 检测对象中的属性是不是自己私有的属性的一个方法
>对象 . hasOwnProperty（“属性名”）
>先用in判断一下有没有这个属性，没有就算了，有的话再用hasOwnProperty的方法判断是不是私有的
```
console.log("X" in ff);
console.log(ff.hasOwnProperty("x"));
//有是true 没有false
```

## 原型模式
>实例通过this得到的是私有属性的方法，还可以继承所属类的共有属性和方法，比如说，每个数组都可以有sort这个方法，这个方法是在类Array原型上，因为所有的数组都是Array类的一个具体的实例，所以只要是数组就可以用。
#### 原型模式
>每一个函数类型，包括函数和所有的类
>**注意：**所有的函数类型都有一个prototype的属性（原型），存储的是共有的属性和方法，这个属性存储的是对象数据类型的，那浏览器就会给它尅皮一个堆内存，开辟的这个堆内存里面又有一个天生自带的属性constructor，而且这个属性指向的是类本身
>**注意：**所有的对象数据类型包括实例和prototype(除了基本数据类型和函数，其他的都是)天生都有一个(——proto——)这个属性，指向所属类的原型。
>**注意：**所有的类都是函数数据类型的，Object是一个类，说明Object是函数数据类型的，那么他就是函数类（Function）的一个实例.

### 原型链
>查找机制：实例 . 属性名，遇到属性名先看是不是自己的私有属性，如果是的话就用私有的，不是的话，通过实例的——proto——找到所属类的原型（prototype）。如果还没有的话，通过所属类的prototype的——proto——继续找，一直找到基类Object的prototype。如果还没有就是undefined。

